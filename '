#!/usr/bin/env python3

# Jan, 2024     
# raheel




from dataclasses import dataclass, field
from enum import Enum, auto, StrEnum
from functools import cached_property

from typing import Any, Protocol
from variables import var
from .assessment import EvaluatedAssessmentRecord
from .evaluation import EvaluatedRecord
from .expression import Expression
from .evaluation import EvaluationContext
from primitives import vlist
from primitives.types import Persona, YMLStrEnum

import logging

log = logging.getLogger(__name__)

# ------ USPSTF Classifications -------
# https://www.uspreventiveservicestaskforce.org/uspstf/about-uspstf/methods-and-processes/grade-definitions

class RecommendationType(YMLStrEnum):
    medication              = 'medication'
    behavioral              = 'behavioral'
    moreEvaluation          = 'evaluation_needed'
    display                 = 'display'
    display_provider        = 'display_provider'
    display_person          = 'display_person'
    evaluation              = 'evaluation'
    patient_facing          = 'patient_facing'

class ProviderDirective(Enum):
    # Do this, do that, ??
    pass 

class UserDirective(Enum):
    discussion_with_provider = auto()
    information = auto()

# --- Strength of evidence
class ClassOfRecommendation(StrEnum):
    I             = 'I'               # benefit >>> risk 
    II_A           = 'IIa'             # benefit >> risk
    II_B            = "IIb"             # benefit >= risk
    III             = 'III: Harm'
    III_Moderate  = "III Moderate"    # benefit = risk
    III_Strong    = "III Strong"      # risk > 

    def color_code_html(self):
        if self == 'I':
            return 'green'
        if self == 'IIb':
            return 'orange'
        if self == 'IIa':
            return 'yellow'
        if self == 'III: Harm':
            return 'red'
        
    @classmethod
    def from_yaml(cls, cor):
        return ClassOfRecommendation(cor) if cor else None


# ---- Quality of evidence ---- 
class LevelOfEvidence(StrEnum):
    A       = "A"           # high quality
    B_R     = "B-R"          # Moderate - Randomized
    B_NR    = "B-NR"        # Moderate - Nonrandomized 
    C_LD    = "C-LD"        # Limited data
    C_EO    = "C_EO"        # Consensus of expert opinion

    @classmethod
    def from_yaml(cls, loe):
        return LevelOfEvidence(loe) if loe else None
    
    def color_code_html(self):
        if self == 'A':
            return 'blue'
        if self == 'B-R':
            return 'light-blue'
        if self == 'B-NR':
            return 'light-blue'
        return 'purple'

    

class USPSTFQualityOfEvidence(Enum):
    Good = auto() 
    Fair = auto() 
    Poor = auto() 

class USPSTFGrading(Enum):

    A = 'A'
    B = 'B'
    C = 'C'
    D = 'D'
    I = 'I'

    def meaning(self):
        if self == USPSTFGrading.A:
            return 'Strongly Recommended'
        if self == USPSTFGrading.B:
            return 'Recommended'
        if self == USPSTFGrading.C:
            return 'No recommendation'
        if self == USPSTFGrading.D:
            return 'Not Recommended'
        if self == USPSTFGrading.I:
            return 'Insufficient Evidence to make Recommendation'

    @classmethod
    def from_yaml(cls, g):
        return USPSTFGrading(g) if g else None


@dataclass(frozen=True)
class RecommendationVar(var.Var):

    expression: str = None
    class_of_recommendation: ClassOfRecommendation = None 
    level_of_evidence: LevelOfEvidence = None 
    uspstf_grade: USPSTFGrading = None 
    type: str = None
    citations: list = field(default_factory=list)
    references: Any = None
    comliance_narrative: str = None
    compliance_expression: str = None
   
    def __hash__(self):
        return super().__hash__()

    @classmethod
    def instantiate_from_yaml(cls, yml, InstantiationContext=None):

        yml['class_of_recommendation'] = ClassOfRecommendation.from_yaml(yml.get('class_of_recommendation', None))
        yml['level_of_evidence'] = LevelOfEvidence.from_yaml(yml.get('level_of_evidence', None))
        yml['uspstf_grade'] = USPSTFGrading.from_yaml(yml.get('uspstf_grade', None))
        yml['type'] = RecommendationType.YAML(yml.get('type', None))

        return super(RecommendationVar, cls).instantiate_from_yaml(yml)

    def as_dict(self):

        d = super().as_dict()
        d.update({
            'level_of_evidence': self.level_of_evidence or None,
            'class_of_recommendation': self.class_of_recommendation or None,
            'uspstf_grade': self.uspstf_grade or None 
        })
        return d


@dataclass
class EvaluatedRecommendation:
    
    recommendation: RecommendationVar
    based_on: list[EvaluatedAssessmentRecord] = None 
    expression: Expression = None 
    applies: bool = None 
    error: Exception = None
    narrative: str = None

    @cached_property
    def based_on_records(self):
        """Returns nested record of all assessment records for which this recommendation was based on."""
        all_records = []

        for record in self.based_on:
            
            # rec = record.record if isinstance(record, EvaluatedRecord) else record
            rec = record.record 
            while rec:
                all_records.append(rec)
                for recd in rec.value.source:
                    rec = recd 
            
            # all_records.append(rec)
            # all_records.extend(rec.value.source)
            print(all_records)
            exit()
        
        return all_records
            
        
            

    def __post_init__(self):
        
        if self.recommendation.expression:
            self.expression = Expression(self.recommendation.expression)

    def evaluate(self, evaluated_assessments: vlist.vlist[EvaluatedAssessmentRecord], variables: list[EvaluatedRecord] = None, persona: Persona = Persona.patient):

        if self.recommendation.type and self.recommendation.type.value == RecommendationType.patient_facing.value:
            self.applies = True 
        elif not self.expression:
            raise Exception(f'Cannot evaluate, no expression found for recommendation={self.recommendation.id}') 
        else:
            try:
                eval_result =  self.expression.evaluate_recommendation(evaluated_assessments)
                self.applies = eval_result
                self.based_on = self.expression.evaluated_records
            except Exception as e:
                raise e

        # get text for recommendation
        varible_value_dict = None 
        if self.recommendation.narr.variables:
            records = list(filter(lambda ea: ea.id in self.recommendation.narr.variables, evaluated_assessments + (variables or [])))
            varible_value_dict = {r.id: r.record.as_dict() for r in records}
            log.info(varible_value_dict)
        self.narrative = self.recommendation.narr.get_text(self.applies, persona=persona, sanitization_dict=varible_value_dict)
        
        
    @property
    def title(self):
        return self.recommendation.title



@dataclass(frozen=True)
class RecommendationResult:

    context: EvaluationContext
    recommendations: list[EvaluatedRecommendation]
    
    @property
    def applied(self):
        return list(filter(lambda er: er.applies == True, self.recommendations))


class RecommendationEvaluatorProtocol(Protocol):

    def validate(self) -> bool:
        ...

    def recommendations(self, evaluated_assessments, context: EvaluationContext = None) -> RecommendationResult:
        ... 



class BaseRecommendationEvaluator(RecommendationEvaluatorProtocol):

    def validate(self) -> bool:
        return True

    def recommendations(self, evaluated_assessments, context: EvaluationContext = None) -> RecommendationResult:
        return None






